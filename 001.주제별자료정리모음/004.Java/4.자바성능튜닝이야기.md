








### Serializable을 구현하는 이유  

- Serializable을 구현한다고 해서 반드시 구현해야하는 메서드가 존재하는 것이 아님, 그럼에도 불구하고 왜 구현할까  
- 해당 인터페이스를 구현하면 객체를 직렬화 할 수 있음 (서버와 서버사이의 데이터 전송이 가능해짐)
- 다른 서버로 데이터를 전송하고나 특정자원에 저장할때 해당 인터페이스를 구현하는 것이 중요함



### GC (Garbage Collection)

- 자바에서 사용하는 한정된 메모리가 꽉 찾을때 더 이상 필요없는 객체들을 제고하는 작업 





### 1.  Sting , StrinBuilder, StringBuffer를 통해 연산을 수행한 후 메모리 사용량, 응답시간에 대한 결과를 비교해보기 

- StringBuilder와  StringBuffer가  제공하는 메소드는 동일하다. 

- StringBuffer는 ThreadSafe하게 설계되어있음. 따라서 여러개의 스레드에서 하나의 StringBuffer를 사용해도 문제가 발생하지 않는다. 

- StringBuilder는 단일 스레드에서의 안정성만을 보장한다, 여러개의 스레드에서 하나의 StringBuilder를 사용하면 문제가 발생한다.

- 응답시간, 메모리 상요량 , 생생된 객체수 

- String은  합치는 연산시 마다 매번 객체를 새로 생성한다. 합치기전 객체는 GC의 대상이 되고, 이는 메모리와 cpu 사용률을 증가시킨다.


- 코드를 역컴파일 해보면 실제로 어떻게 되는지도 확인해 볼 수 있음 

- 버전이 높을수록 컴파일러가 자동으르로  String의 비현실적인 연산을 StringBuilder 로 바꿔줌 



### 2. 자료구조 , (데이터을 어디에 효율적으로 담아야할지), 적럴한 Collections 또는 자료구조 사용


### 3. aksqhrans 










